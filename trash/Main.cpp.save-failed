#include <iostream>
#include <random>
#include <chrono>
#include "Engine/API.h"

const double PI = 3.141592653589793;

int main() {
    Engine::API engine(800, 600, "TestEngine");

    engine.disableCursor();

    engine.setSkybox(
        engine.loadSkybox(
            "Skybox\\skybox_side.tga",
            "Skybox\\skybox_side.tga",
            "Skybox\\skybox_up.tga",
            "Skybox\\skybox_down.tga",
            "Skybox\\skybox_side.tga",
            "Skybox\\skybox_side.tga"
        )
    );

    Engine::Model* model = engine.loadModel("lightTest.fbx");

    std::vector<Engine::DGameObject*> objects;
    std::mt19937 generator;
    std::uniform_int_distribution<int> function(-10, 10);
    {
        using Clock = std::chrono::high_resolution_clock;
        Clock::time_point currentTimePoint = Clock::now();
        generator.seed(currentTimePoint.time_since_epoch().count());
    }

    for(int index = 0; index < 5; index++) {
        Engine::DGameObject* gameObject = engine.createDGameObject();
        float X = function(generator),
              Y = function(generator),
              Z = function(generator);
        gameObject->setPosition(glm::vec3(X, Y, Z));
        gameObject->setModel(model);
        objects.push_back(gameObject);
    }

    engine.addEvent("Loop", "OM0", [&]() {
        Engine::DGameObject* gameObject = engine.getDGameObject(0);
        glm::vec3 position = gameObject->getPosition();
        gameObject->setPosition(
            glm::vec3(
                position.x + ((float)(function(generator)) / 100),
                position.y + ((float)(function(generator)) / 100),
                position.z + ((float)(function(generator)) / 100)
            )
        );
    });

    engine.addEvent("Loop", "OM1", [&]() {
        Engine::DGameObject* gameObject = engine.getDGameObject(1);
        glm::vec3 position = gameObject->getPosition();
        gameObject->setPosition(
            glm::vec3(
                position.x + ((float)(function(generator)) / 100),
                position.y + ((float)(function(generator)) / 100),
                position.z + ((float)(function(generator)) / 100)
            )
        );
    });

    engine.addEvent("Loop", "OM2", [&]() {
        Engine::DGameObject* gameObject = engine.getDGameObject(2);
        glm::vec3 position = gameObject->getPosition();
        gameObject->setPosition(
            glm::vec3(
                position.x + ((float)(function(generator)) / 100),
                position.y + ((float)(function(generator)) / 100),
                position.z + ((float)(function(generator)) / 100)
            )
        );
    });

    engine.addEvent("Loop", "OM3", [&]() {
        Engine::DGameObject* gameObject = engine.getDGameObject(3);
        glm::vec3 position = gameObject->getPosition();
        gameObject->setPosition(
            glm::vec3(
                position.x + ((float)(function(generator)) / 100),
                position.y + ((float)(function(generator)) / 100),
                position.z + ((float)(function(generator)) / 100)
            )
        );
    });

    engine.addEvent("Loop", "OM4", [&]() {
        Engine::DGameObject* gameObject = engine.getDGameObject(4);
        glm::vec3 position = gameObject->getPosition();
        gameObject->setPosition(
            glm::vec3(
                position.x + ((float)(function(generator)) / 100),
                position.y + ((float)(function(generator)) / 100),
                position.z + ((float)(function(generator)) / 100)
            )
        );
    });

    Engine::Camera* camera = engine.createCamera();
    engine.setCurrentCamera(camera);

    engine.createSunlikeLight(glm::vec3(1.0, 1.0, 0.3), glm::vec3(0.5), glm::vec3(0, 1, 0));

    camera->setFOV(90.0f);
    camera->setSpeed(10.0f);
    camera->setPosition(glm::vec3(-5, 0, 5));

    bool pressed = false;
    int counter = 0;
    int lightCounter = 0;

    engine.setBinding("fly_front", KEY_W, [&]() {
        camera->processKeyboard(Engine::CAMERA_MOVE_FORWARD, engine.getDeltaTime());
    });

    engine.setBinding("fly_left", KEY_A, [&]() {
        camera->processKeyboard(Engine::CAMERA_MOVE_LEFT, engine.getDeltaTime());
    });

    engine.setBinding("fly_back", KEY_S, [&]() {
        camera->processKeyboard(Engine::CAMERA_MOVE_BACKWARD, engine.getDeltaTime());
    });

    engine.setBinding("fly_right", KEY_D, [&]() {
        camera->processKeyboard(Engine::CAMERA_MOVE_RIGHT, engine.getDeltaTime());
    });

    engine.setBinding("fly_up", KEY_SPACE, [&]() {
        camera->processKeyboard(Engine::CAMERA_MOVE_UP, engine.getDeltaTime());
    });

    engine.setBinding("fly_down", KEY_LEFT_CONTROL, [&]() {
        camera->processKeyboard(Engine::CAMERA_MOVE_DOWN, engine.getDeltaTime());
    });

    engine.setBinding("fire", MOUSE_BUTTON_LEFT, [&]() {
        objects[0]->setPosition(camera->getPosition());
    });

    Engine::Framebuffer lightBuffer;
    lightBuffer.initialize(engine.getWidth(), engine.getHeight());
    Engine::Framebuffer diffuse;
    diffuse.initialize(engine.getWidth(), engine.getHeight());

    std::cout << "Light shader\n";
    Engine::Shader lightShader;
    lightShader.setVertex("Shaders\\LightBuffer.vs");
    lightShader.setFragment("Shaders\\LightBuffer.fs");
    lightShader.compile();

    engine.updateLightsInfo(&lightShader);

    std::cout << "Diffuse shader\n";
    Engine::Shader diffuseShader;
    diffuseShader.setVertex("Shaders\\Diffuse.vs");
    diffuseShader.setFragment("Shaders\\Diffuse.fs");
    diffuseShader.compile();

    std::cout << "Screen shader\n";
    Engine::Shader screenShader;
    screenShader.setVertex("Shaders\\ScreenSpace.vs");
    screenShader.setFragment("Shaders\\ScreenSpace.fs");
    screenShader.compile();

    lightShader.use();
    lightShader.setMat4("projection", *engine.getProjection());

    diffuseShader.use();
    diffuseShader.setMat4("projection", *engine.getProjection());

    screenShader.use();
    screenShader.setFloat("offset", 0);

    Engine::Texture lightTexture(lightBuffer.get2DSampler());
    Engine::Texture diffuseTexture(diffuse.get2DSampler());

    Engine::Plate* screenSpace = engine.createPlate();

    while(engine.isOpen()) {
        glm::vec2 cursorPosition = engine.getCursorPosition();
        camera->processMouseMovement(cursorPosition.x, cursorPosition.y);

        engine.draw();

        lightBuffer.bind();
        Engine::Framebuffer::clearColorBuffer();
        Engine::Framebuffer::clearDepthBuffer();
        lightShader.use();
        lightShader.setMat4("view", camera->getViewMatrix());
        for(auto object = objects.begin(); object != objects.end(); object++) {
            (*object)->draw(&lightShader);
        }

        diffuse.bind();
        Engine::Framebuffer::clearColorBuffer();
        Engine::Framebuffer::clearDepthBuffer();
        diffuseShader.use();
        diffuseShader.setMat4("view", camera->getViewMatrix());
        for(auto object = objects.begin(); object != objects.end(); object++) {
            (*object)->draw(&diffuseShader);
        }

        engine.disableDepthTest();

        Engine::Framebuffer::bindDefault();
        Engine::Framebuffer::clearColorBuffer();
        lightTexture.bind(0);
        diffuseTexture.bind(1);
        screenShader.use();
        screenShader.setInt("lightBuffer", lightTexture.getActiveUnit());
        screenShader.setInt("diffuseBuffer", diffuseTexture.getActiveUnit());
        screenSpace->draw(&screenShader);

        engine.enableDepthTest();
    }
    return 0;
}














